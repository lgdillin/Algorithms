% !TEX TS-program = pdflatex
% !TEX encoding = UTF-8 Unicode

% This is a simple template for a LaTeX document using the "article" class.
% See "book", "report", "letter" for other types of document.

\documentclass[20pt]{article} % use larger type; default would be 10pt

\usepackage[utf8]{inputenc} % set input encoding (not needed with XeLaTeX)

%%% Examples of Article customizations
% These packages are optional, depending whether you want the features they provide.
% See the LaTeX Companion or other references for full information.

%%% PAGE DIMENSIONS
\usepackage{geometry} % to change the page dimensions
\geometry{a4paper} % or letterpaper (US) or a5paper or....
% \geometry{margin=2in} % for example, change the margins to 2 inches all round
% \geometry{landscape} % set up the page for landscape
%   read geometry.pdf for detailed page layout information

\usepackage{graphicx} % support the \includegraphics command and options

% \usepackage[parfill]{parskip} % Activate to begin paragraphs with an empty line rather than an indent

%%% PACKAGES
\usepackage{booktabs} % for much better looking tables
\usepackage{array} % for better arrays (eg matrices) in maths
\usepackage{paralist} % very flexible & customisable lists (eg. enumerate/itemize, etc.)
\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim
\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float
\usepackage{mathtools}
% These packages are all incorporated in the memoir class to one degree or another...

%%% Other stuff
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}

%%% HEADERS & FOOTERS
\usepackage{fancyhdr} % This should be set AFTER setting up the page geometry
\pagestyle{fancy} % options: empty , plain , fancy
\renewcommand{\headrulewidth}{0pt} % customise the layout...
\lhead{}\chead{}\rhead{}
\lfoot{}\cfoot{\thepage}\rfoot{}

%%% SECTION TITLE APPEARANCE
\usepackage{sectsty}
\allsectionsfont{\sffamily\mdseries\upshape} % (See the fntguide.pdf for font help)
% (This matches ConTeXt defaults)

%%% ToC (table of contents) APPEARANCE
\usepackage[nottoc,notlof,notlot]{tocbibind} % Put the bibliography in the ToC
\usepackage[titles,subfigure]{tocloft} % Alter the style of the Table of Contents
\renewcommand{\cftsecfont}{\rmfamily\mdseries\upshape}
\renewcommand{\cftsecpagefont}{\rmfamily\mdseries\upshape} % No bold!

%%% END Article customizations

%%% nice things to keep around

% \noindent\rule{2cm}{0.4pt} %%% puts a small horizontal line
% \mathcal{O} %%% big O notation

%%% The "real" document content comes below...

\title{Algorithms Homework 4}
\author{Liam Dillingham}
%\date{} % Activate to display a given date or no date (if empty),
         % otherwise the current date is printed 

\begin{document}
\maketitle

An important data structure used that may differ from other student's implementations is the Java TreeSet.  Since the keys must all be unique, I wanted a way to ensure that.  So I used a treeset to contain the randomly generated keys, and used a random integer generator with the constrains where any $x$ produced by the generator falls in the range $0 \leq x \leq 100000$.\\

Then, within a while loop, I randomly generated keys and tried to insert them into the treeset until the size of the treeset equaled 950. Then I partitioned the set of keys into a group of 900, and of 50, as per the assignment. \\

I think it is valuable to note that we used the same auxiliary hash function for all necessary hashing algorithms. As stated in 11.4-1, the hashing function is: $h'(k) = k$, or the identity function. \\

For the linear-probing function, the equation looks as follows: $h(k, i) = (h'(k) + i ) \mod m$ where $i$ is the current number of collisions, and $m$ is the table size. \\ 

For quadratic-probing, we use the function: $h(k, i) = (h'(k) + c_1 * i + c_2 * i^{2}) \mod m$, where $c_1 = 1$, and $c_2 = 3$ as per problem 11.4-1. \\ 

For double-hashing, we have the equation: $h(k, i) = (h_1 (k) + i * h_2 (k)) \mod m$, where $h_1 (k) = k$, and $h_2 (k) = 1 + (k \mod (m - 1)$). \\

Now for the testing results.  For each hashing function, we reuse the same data for both initial hashing, and testing.  However, we use a different/new table for each function.  \\

For the analysis, we use the paritioned dataset of 50 elements, and measure the total number of probes (number of times the function tries to insert a key into the table), and the number of collisions (number of times the function tries to insert and fails).  It should be noted that the number of collisions will always be 50 fewer than the number of probes.  Below are the results:  \\

\begin{verbatim}
# Probes for LINEAR hashing (analysis data): 2077
# Collisions for LINEAR hashing (analysis data): 2027

# Probes for QUADRATIC hashing (analysis data): 592
# Collisions for QUADRATIC hashing (analysis data): 542

# Probes for DOUBLE hashing (analysis data): 520
# Collisions for DOUBLE hashing (analysis data): 470
\end{verbatim}

\\

It was noted to me that it was not necessary to account for random integers, so I did not.  In addition, since the keys must all be unique, it was not necessary to account for duplicate keys

\end{document}
